Functional Dependencies Part 1
  - Relation Design by Decomposition
    - "Mega" Relations + properties of data
    - System decomposes based on properties
    - Final set of relations satisfies normal form
      - No anomalies and no lost information
  - Properties and Normal Forms
    - Functional Dependencies => Boyce Codd Normal Form
    - Multivalued dependencies => Fourth Normal Form
  - Functional Dependencies are generally a useful concept
    - Data storage compression
    - Reasoning about queries - optimization
  - Example : College Application Info
    - Student(SSN,sName,address,HSCode,HSname,HScity,GPA,priority)
    - Apply(SSN,cName,state,date,major)
  - Focus on student
    - Suppose priority is determined by GPA
      - GPA > 3.8 priority 1
      - 3.3 < GPA <= 3.8 priority 2
      - GPA <= 3.3 priority 3
    - Two tuples with same GPA have same priority
      - ∀t,u ∈ student:
        - t.GPA = u.GPA → t.priority = u.priority
        - GPA → priority
      - A → B:
        - ∀t,u ∈ R
        - t.A = u.A → t.B = u.B
      - A1, A2, . . ., An → B1, B2, . . ., Bm:
        - ∀t,u ∈ R
        - t[A1, A2, . . ., An] = u[A1, A2, . . ., An] → t[B1, B2, . . ., Bn] = u[B1, B2, . . ., Bn]
  - Functional Dependency
    - Based on knowledge of real world
    - All instances of relations must adhere

Functional Dependencies Part 2
  - Student(SSN,sName,address,HSCode,HSname,HScity,GPA,priority)
    - SSN → sName
    - SSn → address
    - HScode → HSname, HScity
    - HSname, HScity → HScode
    - SSN → GPA
    - GPA → priority
    - SSN → priority
  - Apply(SSn,cName,state,date,major)
    - cName → date
    - SSN,cName → major
    - SSN → state

Functional Dependencies Part 3
  - Functional Dependencies and key
    - Relation with no duplicates R(A, B)
    - Suppose A → all attributes then it is a key since an attribute determines every other attribute
  - Vocab
    - Trivial Functional Dependency
      - A → B : B ⊆ A
    - Nontrivial Functional Dependency
      - A → B : B ⊈ A
    - Completely Nontrivial FD
      - A → B : B ⊈ A ⋂ B = ∅
  - Rules for Functional Dependencies
    - Splitting rule:
      - A1 → B1, B2, . . ., Bn => A → B1,  A → B2, . . ., A → Bn
      - We can't split the left-hand side
        - HSname, HScity → HScode
    - Combining rule
      - A → B1, A → B2, . . ., Bn => A → B1, B2, . . ., Bn
    - Trivial Dependency Rule:
      - A → B and B ⊆ A
        - A → B then  A → A U B
        - A → B then  A → A ⋂ B
    - Transitive Rule
      - A → B, B → C, then A → C
    - Closure of Attributes
      - Given relation FDs, set of attributes A
      - Find all B such that A → B
      - A+ {A1, . . . , An}+
      - Start with {A1, . . . , An} and repeat until no change
    - Closure example:
      - Student(SSN,sName,address,HSCode,HSname,HScity,GPA,priority)
        - SSN → sName,address,GPA
        - GPA → priority
        - HSCode → HSname,HScity
          - {SSN, HSCode}+ => all attributes => key
    - Closure and key
      - Is A a key for R? -> FD
        - Compute A+ If all attributes then A is a key
      - How can we find all keys given a set of FDs?
        - Consider every subset of attributes
        - A+ -> all attributes : key      

Functional Dependencies Part 4
  - Specifying FDs for a Relation
    - S1 and S2 sets of FDs
    - S2 "follows" S1 if every relation instance satisfying S1 also satisfies S2
      - S2 : {SSN → Priority}
      - S1 : {SSN → GPA, GPA → priority}
    - How to test?
      - Does A → B follow S
      - A+ based on S check if B in set

Functional Dependencies Part 5
  - Specifying FDs for a relation
    - Armstrong's Axioms
    - Want minimal set of completely nontrivial FDs such that all FDs that hold on the relation follow from the dependencies in this set
  - Functional Dependencies are generally useful concept
    - Relational Design by decomposition
      - Functional dependencies => Boyce-Codd Normal Form
      -  Data storage - compression
      - Reasoning about queries - optimization
